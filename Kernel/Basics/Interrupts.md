## Device communication

- Two mechanims to faciliate communication and syncronization between devices
  - Polling
  - Interupts

## Polling

Its a protocol in which CPU steadily checks whether the device needs attention.

## Interrupts

- Hardware signal to the processor asynchronously.
- Devices assiocated with unique value assoicated with each interrupt.
- Generally for hardware interrupts
- Interrupt cannot preempt another interrupt.

## Programmable Interruot controller

- It controls routing of interrupts to CPU.
- NMI - Non maskable interrupts for non recoverable hardware errors.
- NMI will bypass PIC and goes to CPU differently.

## Advanced Programmable Interrupt controller

- Contains routing table.
- We I/O APIC for external interuupts.
- Each CPU core has its own APIC.
- We have Interrupt controller communication bus which will route to local APIC of CPU cores.

## Exceptions / Software Interrupts

- Synchronous with respect to processor timer.
- Generated by processor.
- Divided into 3 types
  - Fault - Segmentation Fault
  - Aborts - Instruction fetch error
  - Trap - Divided by 0, syscall
- Exception cannot prempt interrupt.
- Interrupt can preempt exception.

## Interrpt Descriptor Table

- Used by jump table by CPU when a given vector is triggered.
- Array of 256 \* 8 bytes
- Processor locates IDT by means of IDTR (Register)
- Stores the interrupt handler for devices.
- 8 bytes / 64 bits breakdown
  - 0 to 15 - offset
  - 16 - 31 - segment selector
- Using Segment selector it looks in global descriptor table and finds segment descriptor
- Segement descriptor contains base of interrupt handler and we add offset to get ISR (Interrupt service routine)

## Interrupt Handler

- Kernel code responsible to specific ISR.
- Run in interrupt or atomic context.

## Registering interrupt handler

- `int  request_irq(unsigned int irq, irq_handler_t inrq_handler, unsigned log flags, const char *name, void * dev)`
- Handler flags
  - IRQF_DISABLED
  - IRQF_SAMPLE_RANDOM
  - IRQF_TIMER
  - IRQF_SHARED
- request_irq can sleep and cannot be called interrupt context.
- `static irqeturn_t intr_handler(int irq, void *dev)`

## IRQ vector layout

- in `arch/x86/include/asm/irq_vectors.h`
- 0 to 31 for traps and exceptions
- 32 to 127 for device interupts
- int80 for syscall interface
- 129 to 255 for other interrupts

## References

- https://www.youtube.com/watch?v=yO2orYVUYt0&list=PLsI2APLEA9Eq6z8zUlOJrqmc5KBwLTV4A&index=7
